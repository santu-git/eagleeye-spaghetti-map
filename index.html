<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <style>
    .info-box {
      box-shadow: 5px 10px #888888;
    }

    .baseline {
      stroke-dasharray: 4 4;
    }
  </style>
</head>

<body>

</body>
<script>
  var currentZoom = 0;
  var possiblePaths = [];
  pathBandSize = 10;
  currentTransform = null;
  var canvasSize = 960;
  var drawingPaths = [];
  var scaleX = d3.scaleLinear().domain([0, 6500]).range([0, 960])
  var scaleY = d3.scaleLinear().domain([0, 4595]).range([0, 678.65])
  var randPointGenY = d3.scaleLinear()
    .domain([0.0, 0.5, 1.0])
    .range([-15, 8, 15]);
  var randPointGenX = d3.scaleLinear()
    .domain([0.0, 0.5, 1.0])
    .range([-30, 15, 30]);
  var svg = d3.select("body").append("svg")
    .attr("width", canvasSize)
    .attr("height", canvasSize);

  var svg = svg.append('g').attr('class', 'zoom-layer').call(draw)
    .call(d3.zoom().on("zoom", function () {
      currentZoom = d3.event.transform.k;
      currentTransform = d3.event.transform;
      svg.attr("transform", d3.event.transform)
    }));


  svg.append('g').attr('id', 'image-layer').append('image').attr('xlink:href', 'floor_plan.png').attr('width',
    canvasSize);
  var nodeCanvas = svg.append('g').attr('class', 'node-canvas');
  var pathDrawCanvas = svg.append('g').attr('class', 'path-draw-canvas');
  var pathCanvas = svg.append('g').attr('class', 'path-canvas');
  var longPathCanvas = svg.append('g').attr('class', 'long-canvas');
  var legendCanvas = svg.append('g').attr('class', 'legend-canvas');
  var infoCanvas = svg.append('g').attr('class', 'info-canvas');

  pathLine = d3.line()
    .x(function (d) {
      return d[0];
    })
    .y(function (d) {
      return d[1];
    });
  d3.json('node.json').then(function (rects) {
    nodeCanvas.selectAll('rect').data(rects).enter().append('rect').each(function (d, i) {
      d3.select(this).attrs({
        id: d.id,
        x: d.x,
        y: d.y,
        width: d.width,
        height: d.height,
        'stroke-width': 0.35,
        'stroke': 'black',
        fill: 'none'
      }).on('click', function (d, i) {
        console.log(d, i);
      });
    });

  })
  d3.json('path.json').then(function (paths) {
    possiblePaths = pathDrawCanvas.selectAll('path').data(paths).enter().append('path').each(function (pathData,
      i) {
      d3.select(this).attrs({
        d: pathLine([pathData.src, pathData.dst]),
        'stroke': 'grey',
        'stroke-width': '0.5',
        fill: 'none',
        opacity: 0.3
      }).classed("baseline", !0);
    })
    renderPath();
  })

  pathDensityGroup = {};
  pathLengthGroup = [];
  pathDensityColor = d3.piecewise(d3.interpolateHsl, ["green", "orange", "red", "black"])
  //multiColor = d3.interpolateRainbow;
  multiColor = d3.interpolateSinebow;
  schemeOranges = d3.interpolateOranges;
  schemeBlue = d3.interpolateBlues;

  var curveLine = d3.line().x(function (d) {
    return d[0]
  }).y(function (d) {
    return d[1]
  }).curve(d3.curveLinear);
  //}).curve(d3.curveCardinal.tension(0));

  function renderPath() {
    let lineCount = 0;
    d3.csv("data.csv").then(function (productMoves) {
      let productGroup = d3.nest()
        .key(function (d) {
          return d.product;
        })
        .entries(productMoves);
      //console.log(productGroup);
      for (idx in productGroup) {
        productionLines = productGroup[idx].values
        let productionLinesGroup = d3.nest()
          .key(function (d) {
            return d.production_no;
          }).entries(productionLines);
        for (productLine of productionLinesGroup) {
          lineCount++;
          var points = [];
          for (node of productLine.values) {
            try {
              let bBox = d3.select('#Z-' + node.node).node().getBBox();
              let point = {
                x: (bBox.x + bBox.width / 2),
                y: (bBox.y + bBox.height / 2)
              }
              // // Point position move on x,y based on close path direction.

              //console.log("Shift ", idx, point);
              points.push(point)

            } catch (e) {
              //console.log(node, e);
            }
          }
          points = doDisplacement(points, lineCount);
          getPath(points, idx, lineCount, productLine);

        }
      }
    })
  }

  function doDisplacement(points, lineCount) {
    for (i in points) {
      let nearPath = findNearestPath([points[i].x, points[i].y]);
      let lineDirection = closestPoint(nearPath, [points[i].x, points[i].y], 0);
      if (Math.floor(lineDirection[0]) == Math.floor(points[i].x)) {
        points[i].x += (pathBandSize / 2 - lineCount) * 0.5
      } else {
        points[i].y += (pathBandSize / 2 - lineCount) * 0.5
      }
    }

    return points;
  }

  function findNearestPath(point) {
    let nearestPath = null;
    let distance = Infinity;
    for (pathNode of possiblePaths.nodes()) {
      let current = closestPoint(pathNode, point, 0)
      if (current.distance < distance) {
        distance = current.distance;
        nearestPath = pathNode;
      }
    }
    return nearestPath;
  }

  function getPath(points, productIndex, lineCount, productLine) {
    jaggedPoints = [];
    pairwise(points, function (current, next, index) {
      let nearPath = findNearestPath([current.x, current.y]);
      let x1 = closestPoint(nearPath, [current.x, current.y], (pathBandSize / 4 - lineCount) * 0.5)
      nearPath = findNearestPath([next.x, next.y]);
      let x2 = closestPoint(nearPath, [next.x, next.y], (pathBandSize / 4 - lineCount) * 0.5)
      jaggedPoints.push(...[
        [current.x, current.y],
        [x1[0], x1[1]]
      ]);
      jaggedPoints.push(...[
        [x2[0], x2[1]],
        [next.x, next.y]
      ]);
    });
    productPath = curveLine(jaggedPoints);
    let path = pathCanvas.append('path').attrs({
        d: productPath,
        stroke: multiColor(productIndex * 0.3),
        'stroke-width': 0.1,
        "fill": "none",
        opacity: 0.7,
        class: 'move-path',
      }).call(function (t) {
        return transitionLine(t, 400)
      })
      .on('mouseover', function () {
        renderInfoCanvas({
          product: productLine.values[0].product,
          production_no: productLine.values[0].production_no
        }, {
          x: d3.mouse(this)[0],
          y: d3.mouse(this)[1]
        })
        d3.select(this).attrs({
          'opacity': 1,
          'stroke-width': .3
        })
      }).on('mouseout', function () {
        removeInfoCanvas();
        d3.select(this).attrs({
          'opacity': 0.7,
          'stroke-width': 0.1
        })
      });
  }

  function renderInfoCanvas(data, position) {
    let width = 140 / currentZoom;
    width = isFinite(width) ? width : 140;
    let height = 60 / currentZoom;
    height = isFinite(height) ? height : 60;
    let lineWidth = 1 / currentZoom;
    lineWidth = isFinite(lineWidth) ? lineWidth : 1;
    let offset = 10 / currentZoom
    offset = isFinite(offset) ? offset : 10;
    infoCanvas.append('rect').attrs({
      class: 'info-box',
      x: position.x + offset,
      y: position.y + offset,
      width: width,
      height: height,
      fill: 'white',
      'stroke-width': lineWidth,
      'stroke': 'black',
    })

    let fontSize = 15 / currentZoom;
    fontSize = isFinite(fontSize) ? fontSize : 15;

    let offsetX = 15 / currentZoom
    offsetX = isFinite(offsetX) ? offsetX : 15;

    let offsetY = 30 / currentZoom
    offsetY = isFinite(offsetY) ? offsetY : 30;
    infoCanvas.append("text").text("Product name: " + data.product).attrs({
      x: position.x + offsetX,
      y: position.y + offsetY,
      'font-size': fontSize,
    })
    offsetY = 50 / currentZoom
    offsetY = isFinite(offsetY) ? offsetY : 50;
    infoCanvas.append("text").text("Product Line: " + data.production_no).attrs({
      x: position.x + offsetX,
      y: position.y + offsetY,
      'font-size': fontSize,
    })
  }

  function removeInfoCanvas() {
    infoCanvas.selectAll('text').remove();
    infoCanvas.selectAll('rect').remove();
  }

  function pairwise(arr, func, skips) {

    skips = skips || 1;
    for (var i = 0; i < arr.length - skips; i++) {
      func(arr[i], arr[i + skips], i)
    }
  }
  var lineFunction = d3.line().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  });

  function scrollZoom(selection) {
    d3.zoom().on("zoom", function () {
      selection.attr("transform", d3.event.transform)
    })
  }

  function draw(selection) {
    var xy0,
      path,
      keep = false,
      line = d3.line()
      .x(function (d) {
        return d[0];
      })
      .y(function (d) {
        return d[1];
      });
    var xyPoints = [];
    path = null;
    selection.on("click", function () {
      if (d3.event.shiftKey) {
        if (xyPoints.length == 0) {
          xyPoints.push(d3.mouse(this))
        } else {
          xyPoints.push(d3.mouse(this))
          xyPoints = [];
          xyPoints.push(d3.mouse(this))
        }

        // console.log(svg);
        // svg.append('circle').attrs({
        //   cx: d3.mouse(this)[0],
        //   cy: d3.mouse(this)[1],
        //   r: 0.3,
        //   fill: 'red'
        // });
        // console.log(d3.mouse(this));
      }
    });
    selection.on('click', function () {
        console.log("Mouse Down");
        keep = true;
        console.log(d3.mouse(this));
        xy0 = d3.mouse(this);
        path = d3.select('svg')
          .append('path')
          .attr('d', line([xy0, xy0]))
          .attrs({
            'stroke': 'yellow',
            'stroke-width': '1'
          });
      })
      .on('mouseup', function () {
        keep = false;
        endXY = d3.mouse(this);
        drawingPaths.push([xy0, [endXY[0], endXY[1]]])
        console.log(JSON.stringify(drawingPaths));
      })
      .on('mousemove', function () {
        if (keep) {

          Line = line([xy0, d3.mouse(this).map(function (x) {
            return x - 1;
          })]);
          path.attr('d', Line);
        }
      });


  }

  function closestPoint(pathNode, point, adjustment) {
    var pathLength = pathNode.getTotalLength(),
      precision = 8,
      best,
      bestLength,
      bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {

      if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
        best = scan, bestLength = scanLength, bestDistance = scanDistance;
      }
    }

    // binary search for precise estimate
    precision /= 200;
    while (precision > 0.005) {
      var before,
        after,
        beforeLength,
        afterLength,
        beforeDistance,
        afterDistance;
      if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode
          .getPointAtLength(beforeLength))) < bestDistance) {
        best = before, bestLength = beforeLength, bestDistance = beforeDistance;
      } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after =
          pathNode.getPointAtLength(afterLength))) < bestDistance) {
        best = after, bestLength = afterLength, bestDistance = afterDistance;
      } else {
        precision /= 2;
      }
    }

    let calculatedAdjustment = adjustmentOnPath(point, best, adjustment);
    best[calculatedAdjustment.axis] += calculatedAdjustment.adjustment;
    best = [best.x, best.y];
    best.distance = Math.sqrt(bestDistance);
    return best;

    function distance2(p) {
      var dx = p.x - point[0],
        dy = p.y - point[1];
      return dx * dx + dy * dy;
    }
  }

  function adjustmentOnPath(refCord, actual, adjustment) {
    shiftParams = {
      axis: '',
      adjustment: 0
    };
    if (Math.floor(refCord[0]) == Math.floor(actual.x)) {
      // path on X axis
      shiftParams.axis = 'y'
      shiftParams.adjustment = +adjustment;
    } else {
      //Path On Y axis
      shiftParams.axis = 'x'
      shiftParams.adjustment = +adjustment;
    }

    return shiftParams;
  }

  function rotate(t, a, n) {
    var e = t[0],
      i = t[1],
      r = a[0],
      d = a[1],
      h = e + (r - e) * Math.cos(n) - (d - i) * Math.sin(n),
      o = i + (r - e) * Math.sin(n) + (d - i) * Math.cos(n);
    return [h, o]
  }

  function createJaggedPoints(t, a, n, e) {
    var i = !1;
    if (t[0] > a[0]) {
      var r = t;
      t = a, a = r, i = !0
    }
    var d = t[0],
      h = t[1],
      o = a[0],
      s = a[1],
      g = [t],
      u = s - h,
      c = o - d,
      p = -Math.atan(u / c),
      l = Math.sqrt(Math.pow(o - d, 2) + Math.pow(s - h, 2));
    e || (e = .05 * l);
    for (var v = rotate(t, a, p), w = v[0], m = v[1], f = d; f < w - e;) {
      var P = Math.min(f + e + Math.random() * e, w - e),
        M = n * (Math.random() - .5) + h;
      g.push([P, M]), f = P
    }
    g.push([w, m]);
    var k = g.map(function (n, e) {
      return 0 === e ? t : e === g.length - 1 ? a : rotate(t, n, -p)
    });
    return i ? k.reverse() : k
  }

  function transitionLine(t, a) {
    var n = t.node().getTotalLength();
    t.attr("stroke-dasharray", "0,100000").transition().duration(n / (a / 1e3)).ease(d3.easeQuadOut).attrTween(
      "stroke-dasharray",
      function () {
        var t = this.getTotalLength();
        return d3.interpolateString("0," + t, t + "," + t)
      }).on("end", function () {
      d3.select(this).attr("stroke-dasharray", "none")
    })
  }
</script>

</html>